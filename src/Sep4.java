import java.util.Scanner;
import java.util.*;

//public class Sep4 {
//    public static void main(String[] args){
//        String str1 = "abc";
//        String str2 = new String("abc");
//        System.out.println(str1 == str2);
//        System.out.println(str1.equals(str2));
//        System.out.println(str2);
//    }
//}
class Sep4{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        char chr = ' ';
        System.out.println("문자입력 >");
        String input = scanner.nextLine();
        chr = input.charAt(0);
        if('0' <= chr && chr<= '9'){
            System.out.println("숫자입력");
        } else{
            System.out.println("문자입력");
        }
    }
}
/*
3.2 비트와 바이트
- 바이트: 1비트 8 개를 묶은 것 (4개아님!)
- 워드: CPU 가 한 번에 처리할 수 있는 데이터의 크기
-> 32비트 CPU -> 워드가 4바이트인 컴퓨터
 */
/*
3.5 실수의 진법변환
1)  10진 소수점수 -> 2진 소수점수
    1. 10진 소수에 2 곱하기
        0.625 * 2 = 1.25
    2. 소수부만 떼어서 반복
        0.625 * 2 = 1.25
        0.25 * 2 = 0.5
        0.5 * 2 = 1.0
            소수부가 0이 되면 stop
        => 0.101(2)

2) 2진 소수점수 -> 10진 소수점수
    0.101 = 1 * 2^(-1) + 1 * 2^(-3) = 0.5 + 0.125 = 0.625
 */
/*
4.1 논리형 boolean
- 기본형은 false 이다. 나타내는데 1비트로 충분하지만, 자바의 기본 단위가 바이트기 때문에 크기는 1바이트
4.2 문자형 char
- 문자형은 문자열과 다름을 기억. 문자열은 class 이지만 문자형은 기본 자료형으로 단 하나의 문자만을 저장할 수 있다.
- 아스키: 7 비트를 이용해 기호, 숫자, 영대소문자를 제공하는 약속
- 유니코드: 16비트, 즉 2바이트(16진수로 4자) 이용해 만든 문자 약속. 자바에서는 UTF-16 사용.
- UTF-16: 모든 문자를 2바이트 고정크기로 표현.
- UTF-8: 하나의 문자를 1~4 바이트의 가변크기로 표현, 16•8 모두 처음 128문자가 아스키와 동일.
- 모든 문자의 크기가 동일한 16이 문자를 다루기는 편리하지만, 1바이트로 표현할 수 있는 영어와 숫자가 2바이트로 표현되므로 문서의 크기가 커진다는 단점.
- 전송 속도를 위해 8 인코딩으로 작성된 웹문서가 많아지는 추세.
 */

/*
5. 형변환
: 변수나 리터럴의 타입을 다른 타입으로 변환하는 것. (타입)피연산자
double d = 85.4;
int score = int(d) => score = 85
* boolean 을 제외한 나머지 타입들은 형변환이 가능.
- 기본형과 참조형은 서로 형변환할 수 없다.
- 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

 */
/*
연산자
피연산자의 개수로 연산자를 분류함. 피연산자의 개수가 3개인 삼항 연산자는 오직 ? : 하나뿐이다.
 */
/*
증감 연산자: 피연산자에 저장된 값을 1 증가 혹은 감소시킨다. 이때 상수(final)는 값 변경 불가하므로 X
++ 자체가 +1 을 실행하는 연산이라고 생각해야함.
i = j ++ 을 한다면 j 에도 연산을 실행했기 때문에 j 값도 증가함.

왼쪽에 위치하면 ++i 전위형, 오른쪽에 위치하면 i++ 후위형 => 순서를 생각.
ex)
int i = 5, j = 0;
j = i ++ => i = 6, j =5 => 대입 후 ++ 연산 시행
j = ++ i => i = 6, j = 6 => 연산 시행 후 대입
 */
/*
나누기 연산: 두 피연산자가 모두 int 타입인 경우, 연산결과도 int 로 버림해서 나옴.
          올바른 연산결과를 얻기 위해서는 두 피연산자 중 어느 한 쪽을 실수형으로 변환해 계산.
문자열의 비교: 비교 연산자 == 대신 equals 라는 메서드 사용.

String a = "abc";
String b = new String("b");

둘이 다름. String 은 특별한 클래스라 a 와 같이 생성한 경우를 모아서 관리하고, b의 경우 다른 영역에서 새로운 객체 생성.
String a = "abc", String b = "abc" 로 생성했다면 객체가 2개 생성된 것이 아닌, heap 메모리 내에서 "abc" 의 주소만 a 와 b 에 할당하므로
사실 같은 주소를 공유한는 이름만 다른 같은 객체로 볼 수 있다.
따라서 a == b 는 false, 문자열만 확인하는 a.equals(b) 는 true 이다.

boolean result = abc.equals("abc"); String 클래스의 메소드를 이용.
대소문자를 구별하지 않고 비교하고 싶으면 equalsIgnoreCase 메소드 이용.
 */
/*
논리 연산자의 혼합
2의 배수 or 3의 배수이지만 6의 배수는 아니다 => 괄호를 이용해 명확하게
=> (i % 2 == 0 || i % 3 == 0) & i % 6 != 0

논리 연산자의 효율적인 연산
: or 연산의 경우 어느 한 쪽만 참이어도 나머지는 평가 x, and 도 한쪽이 거짓이면 나머지는 평가 x
=> 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있음!
 */